{"version":3,"sources":["../../../node_modules/regjsgen/regjsgen.js"],"names":["objectTypes","root","window","oldRoot","freeExports","exports","freeModule","module","nodeType","freeGlobal","global","self","stringFromCharCode","String","fromCharCode","floor","Math","fromCodePoint","MAX_SIZE","codeUnits","highSurrogate","lowSurrogate","index","length","arguments","result","codePoint","Number","isFinite","RangeError","push","apply","assertType","type","expected","indexOf","Error","hasOwnProperty","RegExp","test","generate","node","generateAlternative","terms","body","generateTerm","i","generateAnchor","kind","generateAtom","generateCharacterClass","classRanges","negative","generateClassAtom","generateCharacterClassEscape","value","generateCharacterClassRange","min","max","generateDisjunction","generateDot","generateGroup","behavior","behaviour","generateQuantifier","quantifier","undefined","greedy","generateReference","matchIndex","generateValue","toString","toUpperCase","slice","alternative","anchor","characterClass","characterClassEscape","characterClassRange","disjunction","dot","group","reference","define","amd","regjsgen","call"],"mappings":"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","file":"regjsgen.js","sourcesContent":["/*!\n * RegJSGen\n * Copyright 2014 Benjamin Tan <https://d10.github.io/>\n * Available under MIT license <http://d10.mit-license.org/>\n */\n;(function() {\n  'use strict';\n\n  /** Used to determine if values are of the language type `Object` */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Backup possible global object */\n  var oldRoot = root;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */\n\n  var stringFromCharCode = String.fromCharCode;\n  var floor = Math.floor;\n  function fromCodePoint() {\n    var MAX_SIZE = 0x4000;\n    var codeUnits = [];\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    var result = '';\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (\n        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n        codePoint < 0 || // not a valid Unicode code point\n        codePoint > 0x10FFFF || // not a valid Unicode code point\n        floor(codePoint) != codePoint // not an integer\n      ) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        // BMP code point\n        codeUnits.push(codePoint);\n      } else {\n        // Astral code point; split in surrogate halves\n        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n      if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n        result += stringFromCharCode.apply(null, codeUnits);\n        codeUnits.length = 0;\n      }\n    }\n    return result;\n  }\n\n  function assertType(type, expected) {\n    if (expected.indexOf('|') == -1) {\n      if (type == expected) {\n        return;\n      }\n\n      throw Error('Invalid node type: ' + type);\n    }\n\n    expected = assertType.hasOwnProperty(expected)\n      ? assertType[expected]\n      : (assertType[expected] = RegExp('^(?:' + expected + ')$'));\n\n    if (expected.test(type)) {\n      return;\n    }\n\n    throw Error('Invalid node type: ' + type);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  function generate(node) {\n    var type = node.type;\n\n    if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {\n      return generate[type](node);\n    }\n\n    throw Error('Invalid node type: ' + type);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  function generateAlternative(node) {\n    assertType(node.type, 'alternative');\n\n    var terms = node.body,\n        length = terms ? terms.length : 0;\n\n    if (length == 1) {\n      return generateTerm(terms[0]);\n    } else {\n      var i = -1,\n          result = '';\n\n      while (++i < length) {\n        result += generateTerm(terms[i]);\n      }\n\n      return result;\n    }\n  }\n\n  function generateAnchor(node) {\n    assertType(node.type, 'anchor');\n\n    switch (node.kind) {\n      case 'start':\n        return '^';\n      case 'end':\n        return '$';\n      case 'boundary':\n        return '\\\\b';\n      case 'not-boundary':\n        return '\\\\B';\n      default:\n        throw Error('Invalid assertion');\n    }\n  }\n\n  function generateAtom(node) {\n    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');\n\n    return generate(node);\n  }\n\n  function generateCharacterClass(node) {\n    assertType(node.type, 'characterClass');\n\n    var classRanges = node.body,\n        length = classRanges ? classRanges.length : 0;\n\n    var i = -1,\n        result = '[';\n\n    if (node.negative) {\n      result += '^';\n    }\n\n    while (++i < length) {\n      result += generateClassAtom(classRanges[i]);\n    }\n\n    result += ']';\n\n    return result;\n  }\n\n  function generateCharacterClassEscape(node) {\n    assertType(node.type, 'characterClassEscape');\n\n    return '\\\\' + node.value;\n  }\n\n  function generateCharacterClassRange(node) {\n    assertType(node.type, 'characterClassRange');\n\n    var min = node.min,\n        max = node.max;\n\n    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {\n      throw Error('Invalid character class range');\n    }\n\n    return generateClassAtom(min) + '-' + generateClassAtom(max);\n  }\n\n  function generateClassAtom(node) {\n    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');\n\n    return generate(node);\n  }\n\n  function generateDisjunction(node) {\n    assertType(node.type, 'disjunction');\n\n    var body = node.body,\n        length = body ? body.length : 0;\n\n    if (length == 0) {\n      throw Error('No body');\n    } else if (length == 1) {\n      return generate(body[0]);\n    } else {\n      var i = -1,\n          result = '';\n\n      while (++i < length) {\n        if (i != 0) {\n          result += '|';\n        }\n        result += generate(body[i]);\n      }\n\n      return result;\n    }\n  }\n\n  function generateDot(node) {\n    assertType(node.type, 'dot');\n\n    return '.';\n  }\n\n  function generateGroup(node) {\n    assertType(node.type, 'group');\n\n    var result = '(';\n\n    switch (node.behavior) {\n      case 'normal':\n        break;\n      case 'ignore':\n        result += '?:';\n        break;\n      case 'lookahead':\n        result += '?=';\n        break;\n      case 'negativeLookahead':\n        result += '?!';\n        break;\n      default:\n        throw Error('Invalid behaviour: ' + node.behaviour);\n    }\n\n    var body = node.body,\n        length = body ? body.length : 0;\n\n    if (length == 1) {\n      result += generate(body[0]);\n    } else {\n      var i = -1;\n\n      while (++i < length) {\n        result += generate(body[i]);\n      }\n    }\n\n    result += ')';\n\n    return result;\n  }\n\n  function generateQuantifier(node) {\n    assertType(node.type, 'quantifier');\n\n    var quantifier = '',\n        min = node.min,\n        max = node.max;\n\n    switch (max) {\n      case undefined:\n      case null:\n        switch (min) {\n          case 0:\n            quantifier = '*'\n            break;\n          case 1:\n            quantifier = '+';\n            break;\n          default:\n            quantifier = '{' + min + ',}';\n            break;\n        }\n        break;\n      default:\n        if (min == max) {\n          quantifier = '{' + min + '}';\n        }\n        else if (min == 0 && max == 1) {\n          quantifier = '?';\n        } else {\n          quantifier = '{' + min + ',' + max + '}';\n        }\n        break;\n    }\n\n    if (!node.greedy) {\n      quantifier += '?';\n    }\n\n    return generateAtom(node.body[0]) + quantifier;\n  }\n\n  function generateReference(node) {\n    assertType(node.type, 'reference');\n\n    return '\\\\' + node.matchIndex;\n  }\n\n  function generateTerm(node) {\n    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');\n\n    return generate(node);\n  }\n\n  function generateValue(node) {\n    assertType(node.type, 'value');\n\n    var kind = node.kind,\n        codePoint = node.codePoint;\n\n    switch (kind) {\n      case 'controlLetter':\n        return '\\\\c' + fromCodePoint(codePoint + 64);\n      case 'hexadecimalEscape':\n        return '\\\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);\n      case 'identifier':\n        return '\\\\' + fromCodePoint(codePoint);\n      case 'null':\n        return '\\\\' + codePoint;\n      case 'octal':\n        return '\\\\' + codePoint.toString(8);\n      case 'singleEscape':\n        switch (codePoint) {\n          case 0x0008:\n            return '\\\\b';\n          case 0x009:\n            return '\\\\t';\n          case 0x00A:\n            return '\\\\n';\n          case 0x00B:\n            return '\\\\v';\n          case 0x00C:\n            return '\\\\f';\n          case 0x00D:\n            return '\\\\r';\n          default:\n            throw Error('Invalid codepoint: ' + codePoint);\n        }\n      case 'symbol':\n        return fromCodePoint(codePoint);\n      case 'unicodeEscape':\n        return '\\\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);\n      case 'unicodeCodePointEscape':\n        return '\\\\u{' + codePoint.toString(16).toUpperCase() + '}';\n      default:\n        throw Error('Unsupported node kind: ' + kind);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  generate.alternative = generateAlternative;\n  generate.anchor = generateAnchor;\n  generate.characterClass = generateCharacterClass;\n  generate.characterClassEscape = generateCharacterClassEscape;\n  generate.characterClassRange = generateCharacterClassRange;\n  generate.disjunction = generateDisjunction;\n  generate.dot = generateDot;\n  generate.group = generateGroup;\n  generate.quantifier = generateQuantifier;\n  generate.reference = generateReference;\n  generate.value = generateValue;\n\n  /*--------------------------------------------------------------------------*/\n\n  // export regjsgen\n  // some AMD build optimizers, like r.js, check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // define as an anonymous module so, through path mapping, it can be aliased\n    define(function() {\n      return {\n        'generate': generate\n      };\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Narwhal, Node.js, Rhino -require, or RingoJS\n    freeExports.generate = generate;\n  }\n  // in a browser or Rhino\n  else {\n    root.regjsgen = {\n      'generate': generate\n    };\n  }\n}.call(this));\n"]}