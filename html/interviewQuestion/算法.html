<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
  //1编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
  /*  function initArr (arr){
      [...arr.join().split(',')].sort(a,b)
    }
    //let arr = [20,37,20,21]
    //let n = 1
    function deleteNth(arr,n) {
      for(let i in arr){
        let time = 0
        let index = null
        for(let j = arr.length-1; j>0; j--){
          if(arr[i] === arr[j]){
            time++
            index = i
          }
        }
        if(time > n){
          arr.splice(index,1)
          i = 0
        }
      }
      return arr
    }
  function deleteNth2(arr, n) {
    let obj = {}
    let newArr = []
    for(let i in arr){
      if(!obj[arr[i]]){
        //Object.assign({[arr[i]]:1},obj)
        //obj.arr[i] = 1
      }else {
       // obj.arr[i]++
      }
    }
    console.log(44,obj)
    /!*obj.forEach((index,item)=>{

    })*!/
    /!*var tempObj = {};
    var newArr = [];
    for(var i=0;i<items.length;i++) {
      if(!tempObj[items[i]]) {
        tempObj[items[i]] = 1;
      } else {
        tempObj[items[i]]++;
      }
      if(tempObj[items[i]]<= count) {
        newArr.push(items[i]);
      }
    }
    console.log(tempObj);
    return newArr;*!/
  }

 // deleteNth2([41, 44, 41, 41, 41, 44, 44, 44, 44, 41, 41, 44, 41, 44, 41, 44, 41], 5)
    console.log(deleteNth2([41, 44, 41, 41, 41, 44, 44, 44, 44, 41, 41, 44, 41, 44, 41, 44, 41], 5));*/

 /* 2.    给字符串排序，字符串内部有个数字，根据数字来排序，如果是空，输出空
  *例
    `"is2 Thi1s T4est 3a" --> "Thi1s is2 3a T4est"  `
    `"4of Fo1r pe6ople g3ood th5e the2" --> "Fo1r the2 g3ood 4of th5e pe6ople" `
    `"" --> ""`*/
  /*order('is2 Thi1s T4est 3a')
  function order(words){
    // ...
    let arr = words.split(' ')
    let newArr = []
    for(let i of arr){
      console.log(i);
      let item = {
        name:i,
        index:i.replace(/[^0-9]/ig,"")
      }
      newArr.push(item)
    }
    newArr.sort((a,b)=>{
      return Number(a.index) - Number(b.index)
    })
    /!*for(let i of newArr){
      for(let j of arr){
        if(i.name === arr){

        }
      }
    }*!/
    console.log(newArr.sort((a,b)=>a-b));
  }*/
  /*
  3.   找出数组中最大的片段
    arr=[-2,1,-3,5,1,-4,6,-7,-1,2]
   */
  //let arr=[-2,1,-3,5,1]
  /*let arr =[-2,1,-3,5,1,-4,6,-7,-1,2]
  getMaxSun(arr)
  function  getMaxSun(arr) {
    let max = 0
    for(let i=2;i<=arr.length;i++){
      //2~arr.length区间
      //console.log(interval);
      let flag = 0 //记住查询的第一个数的位置
      for(let j in arr){ //遍历数组 进行求和
        let sum = 0
        for(let k = 0;k<i;k++){ //找的区间 固定死的 2次 3次...
          sum +=arr[flag+k]
          if(!arr[flag+k]){
            sum = NaN
          }
        }
        if(max<sum){
          max = sum
        }
        flag++
        console.log('----');
      }
      //console.log(max);
    }
    console.log(max);
    return max

  }*/
  /**
   * 4.改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。
   */
  /*for (let i = 0; i< 10; i++){
    setTimeout(() => {
      console.log(i);
    }, 1000)
  }*/
  /**
   * 解构赋值
   */
  /*  let a = 1;
    let b = 2;
    [a,b] = [b,a]
    console.log(a,b);*/
  /*let {
    title: titleOne,
    test:[
      {title:titleTwo}
    ]
  } = {
    title: 'abc',
    test:[
      {title:'test'}
    ]
  }
  console.log(titleOne,titleTwo);*/
  /*let {a:b}
  = {a:'2'}*/
  /**
   * 异步发展史  callback->promise->Generator->async await
   * Promise
   */
    /*let promise = new Promise((resolve,reject) => {
        setTimeout(()=>{
          resolve('i have been resolved')
        },2000)
    })*/
    /*promise.then((res)=>{
      console.log(169,res);
    })*/
    //-------------------
    /*var b = 10;
    function b() {

    }
    console.log(b);//输出10
    //-------------------
    var a;
    function a(){

    }
    console.log(a);//输出a方法
    //-------------------
    function c(){

    }
    var c;
    console.log(c);//输出c方法*/

  /*var b = 10;
  (function b() {
    var b = 20
    console.log(b);
  })()
  console.log('---');
  console.log(b);*/
  /*var fn = function(){
    
  }
  fn = 10
  console.log(200,fn); //输出10*/
  /*function a() {
    console.log('a函数');
    setTimeout(function () {
      console.log('a内的回调函数');
    },0)
  }
  function b() {
    console.log('b函数');
  }
  a();
  b();*/
  /**
   * 有一只青蛙，青蛙最多跳一阶或两阶，一共有n阶台阶，求一共有多少种可能？
   * 最大跳n次，n为偶数最小跳n/2次  n为基数最小跳n/2+1次
   */

    function getTimes(n) {
      if(n === 1){
            return 1
         } else if(n === 2){
            return 2
         } else{
        return(getTimes(n-1) + getTimes(n-2))
      }
    }
  console.log(getTimes(6));

  /*function jumpFloor(target) {
  if(target == 1){
    return 1;
  }
  if(target == 2){
    return 2;
  }
  //第一次有两种选择，然后根据不同的选择，然后开始不同的下一步，但是下一步还是一样有两种选择
  return jumpFloor(target - 1) + jumpFloor(target - 2);
}
console.log(jumpFloor(3));*/

</script>
</html>